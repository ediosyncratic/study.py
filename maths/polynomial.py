"""Polynomials.  Coefficients are assumed numeric.  Only natural powers are considered.
"""

_rcs_id_ = """
$Id: polynomial.py,v 1.1 2003-07-26 22:38:11 eddy Exp $
"""
import types
from basEddy.lazy import Lazy

class invalidCoefficient (TypeError): "Invalid coefficient for polynomial"
class unNaturalPower (TypeError): "Power of variable in polynomial is not a natural number"

class Polynomial (Lazy):
    """Model of the mathematical ring of polynomials.

    Supports normalisation (to leading term 1.x**rank), addition, subtraction,
    multiplication, division/remainder, hcf (highest common factor), a coprime
    test, comparison and evaluation.

    """

    # Should allow the power entities to be tuples (to represent polynomials
    # in many variables).  Coefficients only require the ability to add,
    # multiply and divmod.

    def __init__(self, *args):
        """Constructor.

        If exactly one argument is passed and it is a mapping, its keys are used
        as powers and values as coefficients of each power's term in the
        polynomial; if exactly one argument is passed and it is a sequence, it
        is interpreted as a mapping whose keys are indices into the list and
        values are entries in the list.  Otherwise, each argument must be
        numeric and the arguments are interpreted as if they'd been passed as a
        sequence.

        Thus:
          Polynomial({ power: coeff ... }) == (: sum(: coeff * x**power :) <- x :)

          Polynomial([ co_0_, co_1_ ... ]) ==
          Polynomial(( co_0_, co_1_ ... )) ==
          Polynomial( co_0_, co_1_ ... )   == (: sum(: co_i_ * x**i <- i :) <- x :)

        As special cases of the last, Polynomial( value ) generates the constant
        polynomial value <- x and Polynomial() generates the zero polynomial.
        The polynomial 1 + 2.x + 3.x**2 <- x may thus be generated by any of:
        Polynomial(1,2,3), Polynomial((1,2,3)), Polynomial([1,2,3]) or
        Polynomial({0:1,1:2,2:3}).  The last, dictionary, form is generally
        preferrable for sparse polynomials (ie, rank >> the number of non-zero
        coefficients): tuple form is better for short and sweet forms like that
        illustrated. """

	self.__coefs = {}	# dictionary with natural keys
        try:
            arg, = args
            arg[:]
            raise ValueError # sequence
        except ValueError: self.__fromseq(args)
        except (AttributeError, TypeError, KeyError):
            try: arg.items, arg.get(0, 0)
            except AttributeError: self.__store(0, arg) # constant polynomial
            else: self.__frombok(arg) # dictionary

        # self.__coefs should now be immutable.

    def _get_coeff(val, oktypes=(types.ComplexType, types.FloatType, types.IntType, types.LongType)):
        if type(val) in oktypes: return val + 0.
        elif hasattr(val, '__add__') and hasattr(val, '__mul__'):
            # This means we can use polynomials as coefficients ...
            # likewise, linear maps, &c.
            return val
        else: raise invalidCoefficient

    def __store(self, power, coeff, g=_get_coeff):
        if coeff: self.__coefs[power] = g(coeff)
    del _get_coeff

    def __fromseq(self, seq):
        i = 0
        for v in seq:
            self.__store(i, v)
            i = 1 + i

    def __frombok(self, bok, ok=lambda k, i=types.IntType: type(k) == i):
        for key, val in bok.items():
            if not ok(key) or key < 0: raise unNaturalPower
            elif val != 0: self.__store(key, val)

    def coefficient(self, key): return self.__coefs.get(key, 0.0)

    def _lazy_get_rank_(self, ignored):
	for key in self.__coefs.keys():
	    if self.__coefs[key] == 0.0:
		del self.__coefs[key]
	try: return max(self.__coefs.keys())
	except ValueError: return -1

    def hcf(self, *others):
	for other in others:
            # Euclid's algorithm
            while other: self, other = other, self % other
	return self

    def coprime(self, *others):
	# coprime <=> hcf is a non-zero scalar
	return self.hcf(others).rank == 0

    def _lazy_get_normalised_(self, ignored):
	if self.rank < 0: raise ValueError, "Can't normalise zero"
	return self / self.__coefs[self.rank]

    def __repr__(self):
	# need to modify this so it can cope with non-scalar coefficients
	result = ""
	keys = self.__coefs.keys()
	keys.sort()
        keys.reverse()
        def fmt(num):
            try:
                if num.imag == 0: num = num.real
            except AttributeError: pass
            ans = str(num)
            if ans[0] != '-': return ' +' + ans
            else: return ' ' + ans

	for key in keys:
            val = self.__coefs[key]
            if key == 0: result = result + fmt(val)
            else:
                if val == 1: result = result + " +"
                elif val == -1: result = result + ' -'
                else: result = result + fmt(val)

                if key == 1: result = result + "x"
                else: result = result + "x**%d" % (key)

        if not result: return "lambda x: 0"
        elif result[:2] == ' +': return 'lambda x: ' + result[2:]
        else: return "lambda x:" + result

    __str__ = __repr__

    def __add__(self, other):
        try: sum = other.__coefs.copy()
        except AttributeError: sum = {0: other}

        for k, v in self.__coefs.items():
            sum[k] = sum.get(k, 0) + v

        return Polynomial(sum)

    __radd__ = __add__

    def __sub__(self, other):
	sum = self.__coefs.copy()

        try: bok = other.__coefs
        except AttributeError: sum[0] = sum.get(0, 0) - other
        else:
            for key, val in bok.items():
                sum[key] = sum.get(key, 0) - val

	return Polynomial(sum)

    def __rsub__(self, other):
        try: sum = other.__coefs.copy()
        except AttributeError: sum = {0: other}

        for k, v in self.__coefs.items():
            sum[k] = sum.get(k, 0) - v

        return Polynomial(sum)

    def __mul__(self, other):
	term = {}
        try: bok = other.__coefs
        except AttributeError:
	    for key in self.__coefs.keys():
		term[key] = self.__coefs[key] * other
	else:
	    for key, val in self.__coefs.items():
		for cle, lue in bok.items():
		    sum = key + cle
                    term[sum] = term.get(sum, 0) + val * lue

	return Polynomial(term)

    __rmul__ = __mul__ # abelian multiplication

    def __div__(self, other):
	return self.__divmod__(other)[0]

    def __mod__(self, other):
	return self.__divmod__(other)[1]

    def __divmod__(self, other):
	"""Solves self = q.other + r for r of rank < other.rank: returns (q, r)

	This depends on our coefficients forming a field.
	"""
        try: top = other.rank
        except AttributeError: top, other = 0, Polynomial({0: other})
	if top < 0: raise ZeroDivisionError

	q, r = Polynomial(0.0), self
	got = self.rank

	# We now reduce the rank of r (by at least 1) at each iteration, by
	# shifting x**got - top**.other (with scaling) from r to q*other; thus, as
	# rank r is finite, it must eventually descend to 0.
	while got >= top:
	    scale = Polynomial({ got - top:
				 r.__coefs[got] / other.__coefs[top] })

	    q, r = q + scale, r - scale * other
	    if r.coefficient(got) != 0.0:
		print "Wiping %g x**%d in Polynomial.__divmod__" % (
			r.__coefs[got], got )
		del r.__coefs[got]	# => forcefully set to zero
	    got = r.rank

	return q, r

    def __pow__(self, other, ok=lambda i, t=types.IntType: type(i) == t):
	# Require other to be natural
	result, wer = 1, self
        try:
            if other.rank < 1: other = other.coefficient(0)
            # For some bizarre reason, x**0 isn't evaluated as x.__pow__(0) !
            # When evaluating x ** 0 I find other == Polynomial(0) instead.
        except AttributeError: pass

        try:
            if other < 0: raise TypeError
            if not ok(other):
                i = int(other)
                if i != other: raise TypeError
                other = i
        except (AttributeError, OverflowError, TypeError):
            raise unNaturalPower, other

	while other >= 1:
	    if other % 2: result = result * wer
	    wer, other = wer * wer, other / 2

	return result

    # use << as repeated integration, >> as repeated differentiation
    def __lshift__(self, other):
        """f << n -> nth integral of f"""
        1L << other # evaluate to raise suitable error if any
        while other > 0:
            self, other = self.integral(), other - 1
        return self

    def __rshift__(self, other):
        """f >> n -> nth derivative of f"""
        1L >> other # evaluate in order to raise suitable error if any
        while other > 0:
            self, other = self.derivative, other - 1
        return self

    def _lazy_get_derivative_(self, ignored):
        """Differentiate a polynomial. """
        bok = {}
        for k, v in self.__coefs.items():
            if k: bok[k-1] = k * v
        return Polynomial(bok)

    def integral(self, start=0, base=0):
        """Integrate a polynomial.

        Optional arguments, start and base, specify the constant of integration;
        by default, the integral's value at zero is zero, but if start (whose
        default is 0) is supplied then the integral's value at start will be
        base (whose default is also 0).  Note that self.integral(base=h) is
        equivalent to self.integral()+h. """

        bok = {}
        for k, v in self.__coefs.items():
            bok[k+1] = v / (1.+k)
        ans = Polynomial(bok)
        # assert: ans(0) == 0
        if start: ans = ans - ans(start)
        if base: ans = ans + base
        return ans

    # assert: self.integral().derivative == self
    # assert: self.derivative.integral(x, self(x)) == self, for any x

    # non-zero: safe and unambiguous
    def __nonzero__(self): return self.coefficient(self.rank) != 0.0
    # Comparison: of debatable value
    def __cmp__(self, other):
	answer = cmp(self.rank, other.rank)
	if answer == 0:
	    diff = self - other
	    answer = cmp(diff.coefficient(diff.rank), 0)
	return answer

    def __pos__(self): return self
    def __neg__(self):
	nega = {}
	for key in self.__coefs.keys():
	    nega[key] = - self.__coefs[key]
	return Polynomial(nega)

    def __coerce__(self, other, boktyp=types.DictionaryType):
        try:
            if type(other.__coefs) == boktyp: return self, other
        except AttributeError: pass

	try: return self, Polynomial(other)
	except (unNaturalPower, invalidCoefficient): return None

    # Only useful if we want polys as keys in dictionaries ...
    def _lazy_get__lazy_hash_(self, ignored):
	result = 0
	for key, val in self.__coefs.items():
	    result = result ^ hash(key) ^ hash(val)
	return result

    # How to evaluate a polynomial ...
    # For any T supporting
    # ({(T: :T)}: * :T), ({(V::T)}: * :{coefficients}) and ({(V: :V)}: + :V)
    # evaluation is ({(V: :T)}: :{polynomials})
    def __call__(self, arg):
	"""Evaluate a polynomial as a function

	For a polynomial, p, with coefficients in some domain C, and a value v
	in some domain T supporting *: T-> T-> T, *: C-> T-> V and +: V-> V-> V,
	we can evaluate p(v) by substituting v in as the value of the
	polynomial's formal parameter.
	"""

	result = arg * 0	# NB may be, eg, a matrix
	keys, max = self.__coefs.keys(), -1
	keys.sort()
	keys.reverse()

	for key in keys:	# highest first
	    if max < 0: max = key
	    else:
		while max > key:
		    result, max = result * arg, max - 1

	    result = result + self.__coefs[key]

	while max > 0:
	    result, max = result * arg, max - 1

	return result

    # Calling one polynomial with another as input yields the composite of the two;
    # the following explores undoing that:

    def unafter(self, other):
        """Returns a polynomial which, if fed other, will yield self.

        Requires rank of self to be a multiple of rank of other, among other things.
        """

        residue, result = self, {}

        while residue:
            if residue.rank % other.rank:
                raise ValueError('Cannot factorise', residue, 'via', other)
            p = residue.rank / other.rank
            q, residue = divmod(residue, other ** p)
            assert q.rank == 0
            result[p] = q.coefficient(0)

        return Polynomial(result)

    def _lazy_get_assquares_(self, ignored):
        """Decompose self as a sum of scaled squares, as far as possible.

        Returns a twople, (bok, poly) in which: poly is zero or a polynomial of
        odd rank; bok is a mapping from polynomials to scalars; if each key of
        bok is squared and multiplied by the corresponding value, summing the
        results and adding poly will yield self. """

        bok = {}
        while self.rank % 2 == 0:
            i = self.rank
            k, i = self.coefficient(i), i / 2
            assert k != 0
            z = Polynomial({i: 1})

            while i > 0:
                i = i - 1
                q = (self - k*z*z) / (2*z*k)
                assert q.rank <= i
                z = z + Polynomial({i: q.coefficient(i)})

            bok[z], self = k, self - k * z * z
            #print bok, self

        return bok, self

    def __pure_real(self):
        for v in self.__coefs.values():
            try:
                if v.imag: return None
            except AttributeError: pass

        return 1

    def _lazy_get_isreal_(self, ignored): return self.__pure_real()

    def _lazy_get_sign_(self, ignored):
        """Sort of cmp(self, 0) but yields None if ill-defined or variable. """
        if self.rank < 0: return 0 # definitely everywhere zero
        if self.rank % 1 or not self.isreal: return None
        if self.rank == 0: return cmp(self.coefficient(0), 0)
        b, r = self.assquares
        if r.rank > 0: return None
        row = b.values()
        if r.rank == 0: row.append(r.coefficient(0))
        lo, hi = min(row), max(row)
        if lo > 0: return +1 # definitely everywhere positive
        if hi < 0: return -1 # definitely everywhere negative

        return None # this is over-cautious

    def __nonzero__(self): return self.rank >= 0

    def __never_zero(self): # a much stronger condition !
        if self.rank == 0: return 1
        if self.rank < 0 or self.rank % 2 or not self.__pure_real(): return None
        b, r = self.assquares
        if r.rank > 0: return None
        sign = witness = 0
        for k, v in b.items():
            if sign < 0:
                if v > 0: return None
            elif sign > 0:
                if v < 0: return None
            else: sign = v

            if k.rank == 0:
                witness = k.coefficient(0)

        if witness: return 1
        witness = None
        for k in b.keys():
            if k.__never_zero(): return 1
            if k.rank == 1:
                witness = k.coefficient(0) / k.coefficient(1) # its root

        if witness is not None:
            for k in b.keys():
                if k.rank != 1 and k(witness): return 1

        # Well, self *may* be never zero, but we haven't proved it
        # Further work looking at b's keys
        return None

    def __cmp__(self, other): return (self - other).sign or 0

    from cardan import cubic
    def seek_root(self, guess=0, tol=1e-6, cub=cubic):
        if self.rank < 1:
            raise ValueError, 'constant function is either nowhere or everywhere zero'

        if self.rank < 4 and self.isreal:
            ans = apply(cub, map(self.coefficient, (3, 2, 1, 0)))
            nice = filter(lambda x: x == long(x), ans)
            if nice: return max(nice)
            return max(ans)

        if self.normalised.sign and (guess + 0j).imag == 0:
            guess = guess + 1j # a pure real start point won't work

        grade, off = self.derivative, self(guess)
        while abs(off) > tol:
            d = grade(guess)
            #print 'Trying:', guess, '->', off, '@', d
            if d: guess = guess - off / d
            else: # at a stationary point
                try: guess = wobble + guess
                except NameError:
                    if not self.isreal or self.sign: spin = 1 +1j
                    else: spin = -2
                    #print 'Spinning:', spin
                    wobble = spin
                    guess = guess + wobble
                wobble = wobble * spin
                #print 'Wobbling:', wobble

            off = self(guess)

        return guess

    del cubic

    def seek_factor(self, guess=None):
        # do newton-raphson in the vector space of quadratic factors
        # stay within real if all coefficients are real
        if self.rank < 2: return self.normalised
        try:
            if guess.rank < 1: guess = None
        except AttributeError: guess = None

        if guess is None:
            try: root = self.seek_root()
            except ValueError:
                assert self.rank == 2
                return self.normalised

            if self.isreal:
                try:
                    if root.imag:
                        guess = Polynomial({2: 1,
                                            1: -2 * root.real,
                                            0: root.real**2 +root.imag**2})
                except AttributeError: pass

            if guess is None:
                guess = Polynomial({1: 1, 0: -root})

        tiny = 1e-6 * min(map(abs, self.__coefs.values()))
        index = range(guess.rank) # not including rank itself;
        # leave guess' 1st coefficient alone; and r's rank is less than that of guess.
        while 1:
            r = self % guess
            if r.rank < 0: return guess # exact factor
            if max(map(abs, r.__coefs.values())) < tiny: return guess # pretty close
            small = 1e-3 * min(map(abs,
                                   r.__coefs.values() + guess.__coefs.values()))

            matrix = []
            for i in index:
                q = guess + Polynomial({i: small})
                d = (r - self % q) / small
                row = []
                for j in index:
                    row.append(d.coefficient(j))
                matrix.append(row)

            raise NotImplementedError, 'Need to divide vector by matrix'
            guess = guess - r / matrix # implement this ...

    def _lazy_get_factors_(self, ignored):
        ans = []
        while self.rank > 0:
            f = self.seek_factor()
            ans.append(f)
            self = self / f

        if self != 1:
            ans.append(self.coefficient(0))
        return ans

del types, Lazy

_rcs_log_ = """
$Log: polynomial.py,v $
Revision 1.1  2003-07-26 22:38:11  eddy
Initial revision

"""
