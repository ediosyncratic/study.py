"""Package to handle lazy infinite list of primes.

A counting number is a prime precisely if its only divisors are 1 and itself.
Formally, every integer n generates an ideal {n*i: i is an integer} and an
integer is a prime if it is greater than one and the only ideal which subsumes
its ideal is the ideal generated by 1 (which is all of the integers).  From
this, one can infer that every positive integer may be expressed as a multiple
of primes, raised to various powers.  It can also be shown (quite easilly) that,
for any finite set of primes, there is a prime not in the set (this amounts to
saying there are infinitely many primes); simply multiply the given primes
together and add one to obtain a number which is not a multiple of any of the
given primes; when it is written as a product of primes, the primes used are
thus not in your set.

To determine whether a positive number is a prime, one must check to see if any
integer greater than 1 divides it.  Since only smaller numbers *can* divide it,
one only needs to check smaller numbers.  Since any divisor's divisors shall
divide it, we only need to check *primes* smaller than our candidate prime.
Furthermore, if n does have a factor then it is n = i * j for some i and j; and
min(i, j) is then sure to be no greater than the square root of n; any prime
factor of min(i, j) is thus necessarily no greater than n's square root.  Thus
we only actually have to check for divisors among the primes whose squares are
less than the candidate.

When checking a range of integers to determine which of them are primes, it is
efficient to check them all at once, using a technique discovered in antiquity
and known as 'the sieve of Eratosthenes'.  The sieve works by, for each prime p
whose square is not beyond the end of the range, running through the range of
numbers marking each multiple of p as not a prime.  In fact it suffices to start
with p*p or the smallest multiple of p in the range (if this is larger), since
any earlier multiples of p shall be marked as multiples of some earlier prime.
When you have done this for all relevant primes, any numbers that remain
unmarked must be primes; the non-primes fall through the holes in the sieve,
leaving only the primes.

When checking an individual number, to determine whether it is a prime, I first
iterate through the already-known primes with squares less than it, checking
each as a candidate factor.  If we find a factor, it's not prime.  If all primes
up to its square root are known and we find no factor, it's prime.  Otherwise,
for all numbers below some cut-off, we know whether or not they're prime; our
candidate exceeds the square of that cut-off.  We may know some primes beyond
that cut-off, so it's worth checking all of these (even those whose squares
exceed our candidate) before going onwards.  Lacking a factor at this point, we
begin (or resume) work on sieving the numbers between the cut-off and some new
cut-off whose square is slightly above our candidate.  When we've finished
sieving out multiples, in this range, of the prime p we know all primes up tp
p*p; as this extends our list of known primes, we check our candidate against
new entries; if we find a factor, we suspend the sieve (leave it to be resumed
next time we need to extend our range).

One can also resort to some clever number-theoretic tricks, which provide
computationally cheap tests which will, with probability very close to one
(closer than the probability of a determinist check completing without being
perturbed by cosmic rays or other hardware errors), spot a non-prime with much
less computational effort than would be needed to actually find a divisor.
These depend on raising randomly chosen values to carefully chosen powers modulo
the alleged prime (or possibly some related numbers, I'm not familiar with the
details) and checking the results against the value that should result if the
number were a prime; for example, for any prime p and natural n which is not a
multiple of p, n**(p-1) is 1 modulo p.  However, these techniques are not (yet)
used here, since my interest is principally in factorising values, rather than
determining whether they are primes.

Various potential improvements on existing ../primes.py:

 * Turn it all into a separate sub-package, maths/prime/ !
    - abandon the misleading 'generalization' of lazyTuple; be entirely focussed
      on a lazy tuple of primes.  In particular, the grow() protocol is
      inappropriate.

 * Iterator support:
   - Support interface in existing class.
   - By providing an iterator class.
   - Use this iterator class in the computation of new primes.

 * Cache improvements:
   - Ensure that all uses load from cache in preference to working out afresh
     (current .grow()-based approach doesn't).
   - Use hex in file-names, rather than base ten.
   - Support use of sub-directories in the cache to provide a hierarchical cache;
     avoid over-large individual directories.
   - Add a variable second letter to file-name prefix; change each time we add a
     digit to start index (so ls gets order right); allow to wrap round a-z
     since we should be in a separate sub-dir by then !
   - Change format to sequence of [ 1, 7, 11, 13, 17, 19, 23, 29 ] octets to
     limit growth in file size (change init to [2, 3, 5], to go with that);
     this'll make a bigger block-size practical.
   - Think in terms of writing a .so module to implement crucial parts, when
     implementing octet format.
   - Retain *one* old-style cache file for an initial chunk of (at least 3)
     primes, plus sparse (which has no place in octet format).
   - Turn primary object into a holder for objects describing sub-ranges; load
     and unload these as needed, to limit how much is held in memory; iterators
     need to remember their positions in terms of chunk identification and
     offset, since chunk may get unloaded between next()s and file hierarchy may
     get re-organized so the chunk's file-name has changed.
   - Support for list of read-only caches from which to borrow data; default
     from $STUDY_PRIME_PATH else empty.
   - Change default cache dir; $STUDY_PRIME_DIR else ~/.study/primes
   - Support (at least initially) an 'old-style cache dir' so we can digest old
     data into new cache format; let it keep the old default.

 * Miscellaneous
   - After exhausting factorise()'s trawl through known primes, try around the
     number's (approximate) square root (see 'Conjecture' in ../primes.py).

Special cases:

  * When is pow(2,n)+1 a prime ?  When n is in (1,2,4,8,16) and then no more, at
    least as far as 42.  Note that pow(2,32)+1 is 641*6700417

  * When is pow(2,n)-1 a prime ?  Never with n even; and n=1 gives 1.  When n is
    in (3,5,7,13,17,19,31) and then no more, at least as far as 60
    - Observe 31=pow(2,5)-1, 17=pow(2,4)+1, 7=pow(2,3)-1, 5=pow(2,2)+1, with
      pow(2,1)-1=1.
    - So when is pow(2, pow(2,i)+pow(-1,i))-1 a prime ?  For i=1 we get 1 which
      we ignore, then for i in (2,3,4,5,6) we get primes.

  * For prime p, if p**2 + n is prime for some natural n then: n is not 0; for q
    in {2, 3}, (n+1)%q is not zero unless p == q; otherwise, n is even, n%6
    isn't 2 and, for n <= 210, I've found it easy to find moderately large
    members of {primes p: p**2+n is prime}, so I conjecture that this set is
    infinite.

Things to do once stuff is into CVS:
 * general TODOs
 * systematic elimination of needless checking hi and len for None
 * move much of what's special about Master onto Sequence (or Branch); make
   Master a class simply derived from Branch, that adopt()s its Head() and
   Bud(); Tail() remains special.
 * make more of Sequence's magic methods simply pass through to Master
 * make all .lo, .hi and .start be relative to .up's .lo and .start
 * size() should return size added when load()ing self, not size of self
 * efficiency TODOs (c.f. Sequence pass-through; and integrate slicer with Master)

$Id: __init__.py,v 1.4 2008-05-04 13:55:48 eddy Exp $
"""

from sequence import primes
# so you can: from study.maths.prime import primes
# See also: study.maths.prime.tool (once I've renamed ../primes.py and pruned it)
