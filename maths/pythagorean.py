"""Generate pythagorean triangles.

Provides:
  Triangle -- an object describing a pythagorean triangle
  triangles() -- an iterator over pythagorean triangles
  tightening() -- decorator to help filter triangles
  Triangles -- A cacheing iterator over coprime pythagorean triples
  Octant -- An iterator over points on a circle
  circles() -- An iterator over circles with pythagorean points
  svgCircles() -- A representation of circles() in SVG
  equiHypot() -- Group int-lattice points with equal sums of squares

See study.LICENSE for copyright and license information.
"""
from study.cache.property import lazyprop
from study.maths.polygon import Triangle

class Triangle (Triangle):
    """Describes a pythagorean triangle.

    The triple (h, e, n) returned by .edges satisfies the pythagorean
    equality, h * h = e * e + n * n.

    The property .inradius is the radius of the incircle - the
    smallest circle that can be inscribed inside the triangle.  It is
    also a whole number.  (The radius of the circumcircle, the
    smallest circle that encloses the triangle, passing through its
    vertices, is simply half the hypotenuse; unless an even scale was
    passed to the constructor, they hypotenuse is odd.)
    """
    def __init__(self, i, j, scale = 1):
        """Set up the data that determines all properties.

        Requires two positive whole number arguments, of which the
        first must be greater than the second.  Optionally accepts a
        scale (default: 1), by which to multiply the lengths of the
        edges; this should be a whole number.
        """
        assert i > j, (i, j)
        self.__ij = i, j
        self.__scale = scale
        # Deliberately not calling base's __init__(), as we provide
        # edges as a property.

    def __hash__(self):
        return hash(tuple(sorted(self.edges)))
    def __cmp__(self, other):
        return cmp(sorted(self.edges), sorted(other.edges))

    @property
    def indices(self):
        return self.__ij

    @property
    def scale(self):
        return self.__scale

    @lazyprop
    def edges(self):
        """A triple whose entries are scale times each of:

            2 * (i * (i + 1) + (j + 1) * j) + 1
            2 * (i * (i + 1) - (j + 1) * j)
            (2 * i + 1) * (2 * j + 1)

        in that order: the first is the hypotenuse, the second is a
        multiple of four.  Here, i and j are the two required
        parameters passed to the constructor; and scale is 1 unless
        over-ridden by the like-named parameter to the constructor.

        These are the sides of a right-angle triangle, as may be
        verified by summing the squares of the later two and comparing
        to the square of the first - see

          http://www.chaos.org.uk/~eddy/math/pythagorean.html

        All three entries are positive whole numbers, with e even;
        unless an even scale was passed to the constructor, h and n
        shall be odd.

        Of course, any scaling of one of these is also a pythagorean
        triangle.  See Triangles.coprime() for the same triangle's
        edges rescaled to make its sides mutually coprime.  Every
        pythagorean triangle has this form, for some i, j and
        scaling.\n"""

        i, j = self.__ij
        h = 2 * (i * (i +1) + (j +1) * j) +1
        e = 2 * (i * (i +1) - (j +1) * j)
        n = (2 * i +1) * (2 * j +1)
        assert e**2 +n**2 == h**2
        return tuple(x * self.__scale for x in (h, e, n))

    @lazyprop
    def coprime(self):
        """As edges, but eliminating any common factors.

        Every pythagorean triple with coprime entries is a Triangle(i,
        j).edges for some j in some natural i (with no scaling);
        however, some triples generated by this formula have (odd)
        common factors; this gives the triple in its coprime form.
        Any scale passed to the constructor is ignored.\n"""
        h, e, n = self.edges
        s = self.__hcf(h, e, n)
        return h / s, e / s, n / s

    @lazyprop
    def iscoprime(self):
        return self.__hcf(*self.edges) == 1

    @lazyprop
    def area(self):
        h, e, n = self.edges
        q, r = divmod(e, 2)
        assert r == 0
        return q * n

    @lazyprop
    def inradius(self):
        """The radius of the incircle of the triangle.

        This is the radius of the largest circle that can be drawn
        inside the triangle, just touching its edges.  It is
        necessarily a whole number.
        """
        i, j = self.__ij
        return (2 * j +1) * (i -j)

    def scaled(self, scale):
        """Returns a scaled version of self.

        This has the same .coprime and .indices as self, but each
        entry in .edges is scaled by the given factor.\n"""
        i, j = self.__ij
        return Triangle(i, j, scale * self.__scale)

    def normalised(self, scale=1.):
        """Return self scaled to a given hypotenuse length.

        Optional argument, scale, defaults to 1.  The triangle
        returned has this as its hypotenuse, with other edges scaled
        to match.\n"""
        return self.scaled(scale / self.edges[0])

    def join(self, other, flip=False):
        """Returns a result of combining two triples.

        Required argument, other, is a Triangle object; optional
        second argument, flip, controls which way round it is combined
        with self.  Returns a Triangle, in coprime form, one of whose
        non-right angles is the sum of self's smallest angle and one
        of other's non-right angles, or throws ValueError if this
        angle would be a whole-number multiple of a right angle (as
        will happen for t.join(t, True), see below).

        By default, when flip is false, the smalest angle of other's
        triangle is added to self's smallest; passing a true value for
        flip will instead select other's larger non-right angle.  Note
        that, since each triangle's non-right angles add up to a right
        angle, other.join(self, True) == self.join(other, True) and
        the triangle that would result from adding the larger
        non-right angle of each is equivalent to self.join(other) and
        other.join(self); angles that add up to a half turn have the
        same Sin and the Cos of each is simply minus the other, so
        they describe the same right-angle triangle (for our
        purposes).\n"""

        n, m, k = sorted(self.coprime)
        f, e, h = sorted(other.coprime)
        if flip: f, e = e, f
        # Cos(a) = m/k, Sin(a) = n/k
        # Cos(b) = e/h, Sin(a) = f/h
        # Cos(a+b) = (e*m -n*f)/k/h, Sin(a+b) = (e*n +m*f)/k/h
        return self.fromEdges(k * h, e * m -n * f, e * n + m * f)

    @classmethod
    def fromEdges(cls, h, e, n = None):
        """Construct a Triangle from the lengths of its sides.

        Requires two arguments, the lengths of the hypotenuse and one
        of the other edges; if the third edge's length is also passed
        (and not None), the pythagorean equality is checked;
        otherwise, it is used to infer the third from the firs two.

        All three edge-lengths should be non-zero integers.  Only the
        absolute value of each edge length is taken into account; if
        any negative lengths are passed, the resulting object's .edges
        will only match in magnitude, not sign.

        ValueError is raised if the given parameters do not form or
        imply a valid pythagorean triple; or if the triangle it
        represents is degenerate (has a zero edge).

        Infers the i, j and scale needed to construct the coprime form
        of this triple as a Triangle and returns that Triangle,
        suitably scaled if needed so that its .edges include each of
        the parameters passed to this pseudo-constructor.

        See also: study.maths.polygon.Triangle's fromEdges().\n"""
        if n is None:
            n, r = cls.__sqrt(h * h - e * e)
            if r:
                raise ValueError(
                    "Hypotenuse and given edge don't make a whole third",
                    h, e, n, r)
        elif h * h != n * n + e * e:
            raise ValueError("Edges do not form a pythagorean triple", h, e, n)

        if not all((h, e, n)):
            raise ValueError("Degenerate pythagorean triangle", h, e, n)

        # Having made it past those checks, as long as h, e and n are
        # naturals, everything should work.

        scale = cls.__hcf(h, e, n)
        h, e, n = abs(h / scale), abs(e / scale), abs(n / scale)
        assert e % 2 != n % 2 and h % 2, (h, e, n)

        # Shuffle to get e as the even one:
        if e % 2: e, n = n, e

        assert e % 4 == 0, (h, e, n)
        assert h % 4 == 1, (h, e, n)
        odd, r = cls.__sqrt(h + e)
        assert r == 0, (h, e, n, odd, r)
        i, r = divmod(odd, 2)
        assert r, (h, e, n, odd, r)

        odd, r = divmod(n, odd)
        assert r == 0, (h, e, n, i, odd, r)
        j, r = divmod(odd, 2)
        assert r, (h, e, n, i, odd, r)
        assert i > j, (h, e, n, i, j)

        return cls(i, j, scale)

    from study.maths.natural import hcf as __hcf, desquare as __sqrt
    __hcf = staticmethod(__hcf)
    __sqrt = staticmethod(__sqrt)

    from study.snake.sequence import Ordered as __Growing
    from study.maths.natural import desquare as __root
    __root = staticmethod(__root)
    @classmethod
    def isosceles(cls):
        """Iterate approximately isosceles pythagorean triangles.

        See [0] for details.  We start with Triangle(1, 0) and use
        each short side to generate new pairs of indices that will
        produce further approximations.

        [0] http://www.chaos.org.uk/~eddy/math/pythagorean.html#Isosceles
        """
        queue = cls.__Growing(((1, 0),))
        while queue:
            tri = cls(*queue.pop(0))
            yield tri
            m = min(tri.edges)
            b, r = cls.__root(m**2 +(m+1)**2)
            assert not r
            queue.append((m, b -m -1))
            queue.append((b +m, m))

def triangles(test = lambda tri: tri.iscoprime):
    """Construct an iterator.

    Single argument, test, is a callable accepting a Triangle
    object, used to filter the pythagorean triples generated.
    Each yield is a Triangle for which this filter has returned a
    true value.  The default filter returns the Triangle's
    .coprime attribute, so that we iterate all coprime pythagorean
    triangles.  The standard formula used as internal iterator
    does generate all the coprime ones but includes some that are
    not coprime; you'll see these if you use lambda tri: True.

    Alternatively, one could pass a test that compares some ratio of
    the edges of the triangle to some value, to select triangles by
    the sin, cos or tan of one of its non-right angles - see
    tightening() for a possibly useful example.

    The test can have state and change its condition in light of
    what it has seen: each triangle is only tested once.  (I chose
    not to specify the order.)\n"""
    # Iterate all pairs of naturals i, j with i > j:
    i = 0
    while True:
        j = i = i + 1
        while j > 0:
            j -= 1
            # From each, generate a triangle
            tri = Triangle(i, j)
            if test(tri):
                yield tri

def tightening(tol, scale = 1):
    """Test a computed value against a decreasing tolerance.

    Required first argument, tol, is an initial tolerance, which
    should behave as a positive float; optional second argument,
    scale, is a scaling by which to reduce tolerance on each
    improvement; this defaults to 1.

    Returns a decorator which wraps a function that maps its one input
    to a number; the wrapped result will compare the abs() of this
    number to its current tolerance; each time this abs is less than
    the tolerance, the tolerance is updated to the minimum of this
    smaller abs and the tolerance multiplied by scale.

    Thus

      @tightening(0.1)
      def close(tri):
          h, e, n = tri.edges
          return h * 1. / min(e, n) -2

    makes triangles(close) an iteration over approximations to half an
    equilateral triangle, steadily tightening the tolerance.  Note
    that taking the min of the scaled tolerance and the value that
    beat the tolerance ensures that each triangle that passes the test
    is a better approximation than any seen before.\n"""
    def wrapper(measure, tol = tol, scale = scale):
        def wrapped(v, vals = [tol, scale, measure]):
            t, s, f = vals
            val = abs(f(v))
            if val < t:
                vals[0] = min(val, t * s)
                return True
            return False
        return wrapped
    return wrapper

from study.snake.sequence import Ordered, Iterable
class Triangles (Iterable):
    """Iterator over known coprime pythagorean triples."""
    def __iter__(self):
        return self.__iter()

    @classmethod
    def __iter(cls):
        for hen in cls.__cache: yield hen
        extra = [] # TODO - FIXME: proper safety under async access by many instances
        cls.__fresh.append(extra)
        try:
            for tri in cls.__src:
                hen = tri.coprime
                for it in cls.__fresh: it.append(hen)
                yield hen

                # Now pick up anything anyone else append()ed recently:
                while extra:
                    it = extra.pop()
                    # Ignore the one *we* appended, of course:
                    if it != hen: yield it
        finally:
            cls.__stale(extra)

    class __Cache (Ordered):
        __upinit = Ordered.__init__
        # ValueError on appending duplicates:
        def __init__(self): self.__upinit(unique=None)
        def check(self, tri):
            try: self.append(tri.coprime)
            except ValueError: return False
            else: return True

    __cache = __Cache()
    del __Cache
    __src = triangles(__cache.check)

    __fresh = []
    @classmethod
    def __stale(cls, xtr):
        i, seq = 0, cls.__fresh
        while True:
            try:
                if seq[i] is xtr:
                    got = seq.pop(i)
                    if got is xtr: break
                    # unless asynchronous stuff happened !
                    seq.insert(0, got)
                    # BUG: anything appended between pop and append got missed :-(
            except IndexError: i = 0
            else: i += 1

class Octant (Ordered):
    """Order triangles by size of sharpest angle.

    Is based on study.snake.sequence.Ordered, using the ratio of
    shortest edge to the one perpendicular to it as sort key.

    Methods:

      points(radius) -- iterator over points on a circle
      length(radius) -- one eighth of the circumference of that circle

    The latter can be used to compute the value of pi.\n"""
    __upinit = Ordered.__init__
    def __init__(self, count):
        self.__upinit(key = self.__order)
        seq = iter(triangles())
        while count > 0:
            count -= 1
            self.append(next(seq))

    from ratio import Rational
    @staticmethod
    def __order(tri, Rat=Rational):
        assert isinstance(tri, Triangle)
        a, c = tri.edges[1:]
        return Rat(a, c) if a < c else Rat(c, a)

    from math import hypot
    @staticmethod
    def __hypot(x, y, mh = hypot, Rat=Rational):
        if isinstance(x, Rat):
            return x.hypot(y)
        if isinstance(y, Rat):
            return y.hypot(x)
        return mh(x, y)
    del Rational, hypot

    def points(self, radius = 1.):
        """Iterate the points on a circle of the given radius.

        Optional argument, radius, defaults to 1.  This generates
        points (x, y) for which hypot(x, y) == radius in order of
        increasing x (and thus decreasing y), with 0 < x < y < radius
        and x**2 < radius**2/2 < y**2.  You may well want to start
        with the missing point (0, radius) and end with the mid-point
        between the last and its (y, x) mirror image in the
        diagonal.\n"""
        for tri in self:
            a, c = tri.normalised(radius).edges[1:]
            yield (a, c) if a < c else (c, a)

    def length(self, radius = 1.):
        last, tot, hypot = (0, radius), radius * 0, self.__hypot
        for here in self.points(radius):
            tot += hypot(*(n -p for n, p in zip(here, last)))
            last = here
        # Finally, the distance from the last point to the diagonal,
        # which is half way to its mirror image in that:
        gap = last[1] -last[0]
        tot += hypot(gap, gap) / 2
        return tot

del Ordered, Iterable, lazyprop

def circles(bound):
    """Iterates whole-radius circles on which whole-co-ordinate points lie.

    Takes one argument, bound.  Each yield is a pair of a radius r,
    less than or equal to bound, and a sequence of (e, n) pairs for
    which hypot(e, n) == r, with r and each e and n being positive
    whole numbers.\n"""
    bok = {}
    for edj in Triangles():
        hyp = edj[0]
        if hyp > bound:
            # Shall all future hypotenuses exceed bound ?
            if (hyp + edj[1] - 1) / 2 + 1 > bound:
                break
            continue
        # Is this a new hypotenuse (i.e. radius) ?
        prior = hyp in bok
        if prior: seq = bok[hyp]
        else: seq = bok[hyp] = set()

        tri = Triangle.fromEdges(*edj)
        for h, s in bok.items():
            if h == hyp: continue
            if hyp % h == 0 and not prior:
                seq.update(t.scaled(hyp // h) for t in s)
            elif h % hyp == 0:
                s.add(tri.scaled(h // hyp))
        seq.add(tri)

    for h in sorted(bok):
        assert all(t.edges[0] == h for t in bok[h])
        yield h, tuple(t.edges[1:] for t in bok[h])

def svgCircles(maxRadius=1024, minCount=2):
    # Generator for http://www.chaos.org.uk/~eddy/img/geom/pythcircles.svg
    seq = tuple(s for s in circles(maxRadius) if len(s[1]) >= minCount)
    big = max(len(s) for r, s in seq)
    for r, s in seq:
        yield ('<path d="M0,{0} A{0},{0} 0,0,0 {0},0" stroke="#{1}{1}{1}" />'
               .format(r, hex(int(200 - len(s) * 160 / big))[2:]),
               ('<!-- radius {} -->'.format(r),) +
               tuple('<circle r="2" cx="{0}" cy="{1}" />'
                     '<circle r="2" cx="{1}" cy="{0}" />'.format(*p) for p in s))

from study.snake.sequence import Dict

def equiHypots(top, sides = 2, matches = 2, low = 1, test = lambda k: True,
               Holder = Dict.UsingDefault(False, set)):
    """Integral points on equal-radius spheres.

    This isn't limited to spheres of integer radius, like circles(),
    unless test requires its parameter to be a perfect square.
    Returns a mapping from non-negative integer keys to (frozen) sets
    of tuples.  For each k, vs in the return's .items(): test(k) is
    true, all(len(v) == sides and sum(n*n for n in v) == k for v in
    vs) and len(vs) >= matches.  The entries in each v in vs are in
    non-increasing order; each entry is an int (or long) neither less
    than floor(low) nor greater than ciel(top).  Because tuples in vs
    are in non-increasing order, no two are permutations of one
    another; so the set of tuples, for each key, is only exhaustive
    modulo permutation.

    The default test accepts every value for k, the default for low is
    1 and those for sides and matches are two.  This gives
    non-increasing twoples with entries ranging from 1 through top,
    inclusive, grouped by equality of sum of squares and only
    including groups that exhibit at least two distinct ways to get
    the same same sum of squares.\n"""
    # Advertised coercing of top to ciel, low to floor:
    n = int(low // 1) # Guaranteed to round *down* (not towards zero)
    if n != low: low = n
    n = int(top // 1)
    if n != top: top = n + 1 # (but we want to round top *up*)

    # Iterate candidate tuples:
    bok, v = Holder(), (top,) * sides
    while v[-1] >= low:
        key = sum(n * n for n in v)
        if test(key):
            bok[key].add(v)
        n = 0
        while n +1 < sides and v[n] <= low: n += 1
        v = (v[n] - 1,) * (n +1) + v[n + 1:]

    return {k: frozenset(vs) for k, vs in bok.items() if len(vs) >= matches}

del Dict
