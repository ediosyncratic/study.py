"""Generate pythagorean triangles.

See study.LICENSE for copyright and license information.
"""
from study.cache.property import lazyprop

class Triangle (object):
    """Describes a pythagorean triangle.

    The triple (h, e, n) returned by .edges satisfies the pythagorean
    equality, h * h = e * e + n * n.

    The property .inradius is the radius of the incircle - the
    smallest circle that can be inscribed inside the triangle.  It is
    also a whole number.  (The radius of the circumcircle, the
    smallest circle that encloses the triangle, passing through its
    vertices, is simply half the hypotenuse; unless an even scale was
    passed to the constructor, they hypotenuse is odd.)

    """
    def __init__(self, i, j, scale = 1):
        """Set up the data that determines all properties.

        Requires two positive whole number arguments, of which the
        first must be greater than the second.  Optionally accepts a
        scale (default: 1), by which to multiply the lengths of the
        edges; this should be a whole number.
        """
        assert i > j
        self.__ij = i, j
        self.__scale = scale

    @lazyprop
    def edges(self):
        """A triple whose entries are scale times each of:

            2 * (i * (i + 1) + (j + 1) * j) + 1
            2 * (i * (i + 1) - (j + 1) * j)
            (2 * i + 1) * (2 * j + 1)

        Here, i and j are the two required parameters passed to the
        constructor; and scale is 1 unless over-ridden by the
        like-named parameter to the constructor.

        These are the sides of a right-angle triangle, as may be
        verified by summing the squares of the later two and comparing
        to the square of the first - see

          http://www.chaos.org.uk/~eddy/math/pythagorean.html

        All three entries are positive whole numbers, with e even;
        unless an even scale was passed to the constructor, h and n
        shall be odd.

        Of course, any scaling of one of these is also a pythagorean
        triangle.  See Triangles.coprime() for the same triangle
        rescaled to make its sides mutually coprime.  Every
        pythagorean triangle has this form, for some i, j and
        scaling.\n"""

        i, j = self.__ij
        h = 2 * (i * (i +1) + (j +1) * j) +1
        e = 2 * (i * (i +1) - (j +1) * j)
        n = (2 * i +1) * (2 * j +1)
        assert e**2 +n**2 == h**2
        return tuple(x * self.__scale for x in (h, e, n))

    @lazyprop
    def coprime(self):
        """As edges, but eliminating any common factors.

        Every pythagorean triple with coprime entries is a Triangle(i,
        j).edges for some j in some natural i (with no scaling);
        however, some triples generated by this formula have (odd)
        common factors; this gives the triple in its coprime form.
        Any scale passed to the constructor is ignored.\n"""
        h, e, n = self.edges
        s = self.__hcf(h, e, n)
        return h / s, e / s, n / s

    @lazyprop
    def iscoprime(self):
        return self.__hcf(*self.edges) == 1

    @lazyprop
    def inradius(self):
        """The radius of the incircle of the triangle.

        This is the radius of the largest circle that can be drawn
        inside the triangle, just touching its edges.  It is
        necessarily a whole number.
        """
        i, j = self.__ij
        return (2 * j +1) * (i -j)

    @classmethod
    def fromEdges(cls, h, e, n = None):
        """Construct a Triangle from the lengths of its sides.

        Requires two arguments, the lengths of the hypotenuse and one
        of the other edges; if the third edge's length is also passed
        (and not None), the pythagorean equality is checked;
        otherwise, it is used to infer the third from the firs two.

        All three edge-lengths should be non-zero integers.  Only the
        absolute value of each edge length is taken into account; if
        any negative lengths are passed, the resulting object's .edges
        will only match in magnitude, not sign.

        ValueError is raised if the given parameters do not form or
        imply a valid pythagorean triple; or if the triangle it
        represents is degenerate (has a zero edge).

        Infers the i, j and scale needed to construct this triple as a
        Triangle and returns that Triangle.\n"""
        if n is None:
            n, r = cls.__sqrt(h * h - e * e)
            if r:
                raise ValueError(
                    "Hypotenuse and given edge don't make a whole third",
                    h, e, n, r)
        elif h * h != n * n + e * e:
            raise ValueError("Edges do not form a pythagorean triple", h, e, n)

        if not all((h, e, n)):
            raise ValueError("Degenerate pythagorean triangle", h, e, n)

        # Having made it past those checks, as long as h, e and n are
        # naturals, everything should work.

        scale = cls.__hcf(h, e, n)
        h, e, n = abs(h / scale), abs(e / scale), abs(n / scale)
        assert e % 2 != n % 2 and h % 2, (h, e, n)

        # Shuffle to get e as the even one:
        if e % 2: e, n = n, e

        assert e % 4 == 0, (h, e, n)
        assert h % 4 == 1, (h, e, n)
        odd, r = cls.__sqrt(h + e)
        assert r == 0, (h, e, n, odd, r)
        i, r = divmod(odd, 2)
        assert r, (h, e, n, odd, r)

        odd, r = divmod(n, odd)
        assert r == 0, (h, e, n, i, odd, r)
        j, r = divmod(odd, 2)
        assert r, (h, e, n, i, odd, r)
        assert i > j, (h, e, n, i, j)

        return cls(i, j, scale)

    from study.maths.natural import hcf as __hcf, desquare as __sqrt
    __hcf = staticmethod(__hcf)
    __sqrt = staticmethod(__sqrt)

def triangles(test = lambda tri: tri.iscoprime):
    """Construct an iterator.

    Single argument, test, is a callable accepting a Triangle
    object, used to filter the pythagorean triples generated.
    Each yield is a Triangle for which this filter has returned a
    true value.  The default filter returns the Triangle's
    .coprime attribute, so that we iterate all coprime pythagorean
    triangles.  The standard formula used as internal iterator
    does generate all the coprime ones but includes some that are
    not coprime; you'll see these if you use lambda tri: True.

    Alternatively, one could pass a test that compares some ratio of
    the edges of the triangle to some value, to select triangles by
    the sin, cos or tan of one of its non-right angles - see
    tightening() for a possibly useful example.

    The test can have state and change its condition in light of
    what it has seen: each triangle is only tested once.  (I chose
    not to specify the order.)\n"""
    # Iterate all pairs of naturals i, j with i > j:
    i = 0
    while True:
        j = i = i + 1
        while j > 0:
            j -= 1
            # From each, generate a triangle
            tri = Triangle(i, j)
            if test(tri):
                yield tri

def tightening(tol, scale = 1):
    """Test a computed value against a decreasing tolerance.

    Required first argument, tol, is an initial tolerance, which
    should behave as a positive float; optional second argument,
    scale, is a scaling by which to reduce tolerance on each
    improvement; this defaults to 1.

    Returns a decorator which wraps a function that maps its one input
    to a number; the wrapped result will compare the abs() of this
    number to its current tolerance; each time this abs is less than
    the tolerance, the tolerance is updated to the minimum of this
    smaller abs and the tolerance multiplied by scale.

    Thus

      @tightening(0.1)
      def close(tri):
          h, e, n = tri.edges
          return h * 1. / min(e, n) -2

    makes triangles(close) an iteration over approximations to half an
    equilateral triangle, steadily tightening the tolerance.  Note
    that taking the min of the scaled tolerance and the value that
    beat the tolerance ensures that each triangle that passes the test
    is a better approximation than any seen before.\n"""
    def wrapper(measure, tol = tol, scale = scale):
        def wrapped(v, vals = [tol, scale, measure]):
            t, s, f = vals
            val = abs(f(v))
            if val < t:
                vals[0] = min(val, t * s)
                return True
            return False
        return wrapped
    return wrapper

from study.snake.sequence import Ordered, Iterable
class Triangles (Iterable):
    """Iterator over known coprime pythagorean triples."""
    def __iter__(self):
        for hen in cls.__cache: yield hen
        extra = [] # TODO - FIXME: proper safety under async access by many instances
        cls.__fresh.append(extra)
        try:
            for tri in cls.__src:
                hen = tri.coprime
                for it in cls.__fresh: it.append(hen)
                yield hen

                # Now pick up anything anyone else append()ed recently:
                while extra:
                    it = extra.pop()
                    # Ignore the one *we* appended, of course:
                    if it != hen: yield it
        finally:
            cls.__stale(extra)

    class __Cache (Ordered):
        __upinit = Ordered.__init__
        # ValueError on appending duplicates:
        def __init__(self): self.__upinit(unique=None)
        def check(self, tri):
            try: self.append(tri.coprime)
            except ValueError: return False
            else: return True

    __cache = __Cache()
    del __Cache
    __src = triangles(__cache.check)

    __fresh = []
    @classmethod
    def __stale(cls, xtr):
        i, seq = 0, cls.__fresh
        while True:
            try:
                if seq[i] is xtr:
                    got = seq.pop(i)
                    if got is xtr: break
                    # unless asynchronous stuff happened !
                    seq.insert(0, got)
                    # BUG: anything appended between pop and append got missed :-(
            except IndexError: i = 0
            else: i += 1

del Ordered, Iterable
